##  Object.defineProperty, Classes, and Inheritance

###  Introduction

Ecmascript 5 was released few years ago now and it brought some great new additions to Javascript. Some of my favorites include `Array` iteration and `"use strict"`. Obviously, there are more than those, but when you work on the client side there isn't always a shim available to support older browsers (you know who you are). 

Because of this, some great methods aren't put to use. One of these methods is `Object.defineProperty`. There is not a shim for this method and there never will be. This method allows you to make better use of the browsers internals concerning **setters/getters** and if something is **writable**, **configurable**, or **enumerable** which a shim can't cover.

If supporting older browsers isn't in your projects requirements or you're using `nodejs` then we can make use of the awesome powers that `ES5` gave us. I will be using `Object.defineProperty` and some other useful `Object` static methods in the rest of this post. If you are unfamiliar with them, I suggest you review them before continuing. 

Here are some good sources to check out:

* [John Resig on ES5](http://ejohn.org/blog/ecmascript-5-objects-and-properties/)
* [MDN `Object.defineProperties`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperties) 
* [MDN `defineProperty`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty)     

### Creating a class

Creating a class in JS is pretty simplistic. Define a `function` then add some properties and methods. Defining a class the class way has some serious flaws. Everything can be overwritten! 

Let's take a look.

```javascript
function Dog(name, age) {
    this.name = name;
    this.age = age;
}
```

If we instantiate this class we can change the values at anytime. Now, depending on our requirements, this might be okay, but frankly, I don't change my dog's name once it has been set. Let's fix this using `Object.defineProperty`.

```javascript
function Dog(name, age) {

    Object.defineProperty(this, {
        name: {
            value: name,
            enumerable: true
        },
        age: {
            set: function (value) {
                value = parseInt(value, 10);
                if (isNaN(value))  throw new Error("value set on age is not a number");
                age = value;
            },
            get: function () {
                return age;
            },
            enumerable: true
        }
    });
}
```

I used `ES5` syntax in a few different ways here. For the `name` property I set a **`value`**. If the `writable` property is not set, it defaults to false.  The `age` property uses  a **`setter`** and **`getter`**.  Whenever I set a value to `age`  it will automatically be converted to a `Number` or throws an `Error`. Awesome, but we're not done yet! Let's add some methods to our `Dog` class.

```javascript

Object.defineProperties(Dog.prototype, {
    bark: {
        value: function () {
            console.log("Bark!");
        }
    } 
});

``` 

Dog gets a basic `bark` method, but notice the omission of the `enumerable` property. If a user of class for some reason decides to iterate of over a `dog` object; this method will be omitted from the iteration. Nice! No need to test if the property you are currently iterating is a `Function` or not. Sweet!

> Note: If it is important to know what methods exist on the prototype use the [`Object.getOwnPopertyNames`](http://https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames) method to see all of the non-enumerable properties.

### Adding Inheritance

At this point, we have a fully working `Dog` class, but a dog has a many forms, err breeds. Let's get subclassing!

I'll be using a simple inheritance script that is generated by [coffescript](http://www.coffeescript.org) to subclass objects. As seen here:

```javascript

var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

```

Let's create a `Bulldog` class:

```javascript

__extends(Bulldog, Dog);

function Bulldog() {
    Dog.__super__.constructor.apply(this, arguments);
}

Object.defineProperties(Bulldog.prototype, {
    bark: {
        value: function () {
            console.log("Wooooof");
        }
    },
    beLazy: {
        value: function () {
            console.log("Zzzzzzz.");
        }
    }
});

```

Pretty simple. I override `Dog`'s speak method with my another. Neither of these methods have have properties set other than value keeping it nice and safe. These properties cannot be overriden or deleted.

### Going Final

JS doesn't have classes, but we simulate them. JS also doesn't have the notion of `final` for a "class", but we can do something like it! `Object.freeze` allows us to stop any sort of modification of an object.

[MDN `Object.freeze`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze)

Let's make it so not only user's of our `Bulldog` class can't override methods, but can't **add** any either. 

It's as simple as, `Object.freeze(Bulldog.prototype)`. In `strict mode` an error will be thrown if someone tries to add methods to this class or fail silently when not in `strict mode`.

### Strict mode

`"strict mode"` is not required to use these features, but it is highly valuable for debugging purposes. If you try to change the value of a property on an on object that isn't `writable` or `delete` a value that isn't `configurable`.

> `TypeError: Cannot assign to read only property 'name' of #<Bulldog>`
> `TypeError: Cannot delete property 'name' of #<Bulldog>`

### Conclusion
`Object.defineProperty` allows us to make our code stricter using native JS. We can protect our objects and properties without wasting time on custom code or new/extra syntax. JavaScript feels the same as you use your objects, but with the delicious sugar of `writable`/`set`/`get`, `configurable`, and `enumerable` descriptors. 

### Demo

I've put together a demo that has a couple of subclasses. I've also commented out some code that will throw errors in `strict mode`. Additionally, I've added some methods that will make adding properties easier along with protecting methods from being overridden in subclasses.  I recommend that you uncomment them so you can see them in action yourself.

The code should run in all modern browsers and in a nodejs environment. 

### After thoughts

#### Sealing Objects
Perhaps we want a subclass to be able to override existing methods, but not add more methods to it. [Object.seal](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal) prevents new methods from being added to the prototype and prevents them from being deleted. All writable methods remain writable and all unwritable remain unwritable.

```javascript
Object.seal(Bulldog.prototype)
// TypeError: Can't add property foo, object is not extensible
Bulldog.prototype.foo = function () {};
```

#### Constants
On the note of making properties unwritable and undeletable, we can make constants!

```javascript

var CONST: {
    PI: Math.PI,
    FOO: "bar"
};

Object.freeze(CONST);

```

